"""Script version: v2.3Developed by : Tor Andreassen and Andry JongSeptember 09. 2012"""import nukeimport osdef fun():    """checking if the nuke-script already contains a fxT_relinker-node, if it does a message pops up, and the script will zoom into that node after the user click OK"""    """if there in no fxT_relinker yet, it will be created"""    if (nuke.exists("fxT_relinker")):        nuke.message("A fxT_relinker-node already exists in your nuke script.\n\n Click OK, and Nuke will zoom into your fxT_relinker in case you need to make changes to the project-path.")        nuke.zoom( 1.6, [ nuke.toNode('fxT_relinker').xpos(), nuke.toNode('fxT_relinker').ypos() ])        nuke.toNode('fxT_relinker').showControlPanel()    else:            """creating a noOp node for filePath purposes"""        """adding a file Knob for user input, a button for kicking off the script (done by the relink function), and adding text for user how to info"""        myNode  = nuke.nodes.NoOp (name = 'fxT_relinker')        myNode['hide_input'].setValue(1)        myNode['tile_color'].setValue(  int('%02x%02x%02x%02x' % (31,107,170,0),16))        myNode['note_font_color'].setValue(  int('%02x%02x%02x%02x' % (255,255,255,0),16))        divider1 = nuke.Text_Knob('DivLine1','')        divider2 = nuke.Text_Knob('DivLine2','')        divider3 = nuke.Text_Knob('DivLine3','')        xpos = myNode.xpos()        ypos = myNode.ypos()        buttonPy = nuke.PyScript_Knob("Relink all read-nodes", "Relink")        myNode.addKnob(divider1)         pathy = nuke.File_Knob("path", "project-path: ")         myNode.addKnob(pathy)        myNode.addKnob(buttonPy)        buttonPy.setValue('fxT_relinker.fxT_relinkerMAIN()')        myNode.addKnob(divider2)        myNode.addKnob( nuke.Text_Knob("","How to use the fxT_relinker:"," "))        myNode.addKnob( nuke.Text_Knob("press 'alt+e' to view or hide the expression pipes","","1) Gather all your footage inside a project-folder. \n\n - How you organize the file and folder-structure \n inside the project-folder does not matter.\n"))        myNode.addKnob( nuke.Text_Knob("press 'alt+e' to view or hide the expression pipes","","2) Click the folder-icon to set your project path.\n"))        myNode.addKnob( nuke.Text_Knob("press 'alt+e' to view or hide the expression pipes","","3) Click the Relink-button. \n\n - That's all there is to it, happy relinking!"))        myNode.addKnob(divider3)        myNode.addKnob(nuke.Text_Knob("devInfo","","<font color='Red'>Developed by Tor Andreassen & Andry Jong"))        """adding a backdrop to the fxT_relinker-node, and zooming into it so the comper can see it in the script"""        backDrop = nuke.nodes.BackdropNode(bdwidth=(150), bdheight=(80))         backDrop.setXpos(xpos-36)        backDrop.setYpos(ypos-50)        backDrop.knob('label').setValue('   fxT_relinker')        backDrop.knob('note_font_size').setValue(25)        backDrop.knob('note_font_color').setValue( int('%02x%02x%02x%02x' % (255,255,255,0),16))         backDrop.knob('tile_color').setValue(  int('%02x%02x%02x%02x' % (31,107,170,0),16))        backDrop.knob('name').setValue ("Comp Workflow Tool")        nuke.zoom( 1, [ backDrop.xpos(), backDrop.ypos() ])        """opening the myNode's properties panel, so the user can see get a graphical interface for doing the relinking"""        myNode.showControlPanel()### LAST UPDATED BY ANDRY JONG ON 09/12/2012 ###### SETUP GLOBAL VARIABLE ###### sourcePath is the user defined path### allFPCombo contains ALL of the File - Path combinations found.### bestFPCombo contains only the BEST File - Path combinations.sourcePath = ""allFPCombo = []bestFPCombo = {}### SETUP FUNCTIONS ###### @legalPath( path ):###     This function will check if user defined path is an actual path or not.###     Raise a warning if the path is not an actual path.def legalPath( path ):    if not os.path.isdir( path ):        nuke.message('The path selected does not exist. \                      Please choose another path.')        return False    else:        return True### @fixNameFormating( filename ):###     This function will replace all of the '\' with a '/',###     because NUKE will get confused otherwise.def fixNameFormating( filename ):    if '\\' in filename:        return filename.replace('\\','/')    else:        return filename### @getBaseName( filename ):###     This function returns the base name of input file name for search purposes.### Base name example:    ###         File Name               Base Name    ###     project_a.####.ext      project_a.###             OR###     project_a.%03d.ext    ###     project_a_####.ext      project_a_###             OR###     project_a_%03d.ext    ###     project_a####.ext       project_a###             OR###     project_a%03d.ext###             OR###     project_a.123.ext### For this, it is important to NOT have # or % characters in your file name.def getBaseName( filename ):    filename = fixNameFormating(filename)    filename = filename.split('/')[-1]    if '\#' in filename:        return filename.split('\#')[0]    elif '%' in filename:        return filename.split('%')[0]    else:        return filename.split('.')[0]### @getFilePath( filename ):###     This function returns a list of folders structure where the file is located.###     It is important to know in case there are multiple files with the same name###     under different folders.### C:/Users/User Name/Folder/project_a.123.ext ---> [C:][Users][User Name][Folder]def getFilePath( filename ):    filename = fixNameFormating(filename)    filepath = filename.split('/')    filepath.pop()    return filepath### @getALLFPCombo( filename, basename, filetype ):###     This function returns any File - Path Combination where###         File = desired file name###         Path = path found by searchdef getALLFPCombo( filename, basename, filetype ):    global sourcePath, allFPCombo        for currentPath, currentDirs, currentFiles in os.walk(sourcePath):        if len(currentFiles) > 0:            for currentFile in currentFiles:                if currentFile.startswith(basename) and currentFile.endswith(filetype):                                              currentPath = fixNameFormating(currentPath)                       allFPCombo.append([filename, currentPath])### @getBestFPCombo( filename, filepath ):###     This function finds the best path for a given file name in case###     there are more than 1 match.def getBestFPCombo( filename, filepath ):    global allFPCombo, bestFPCombo        FPDList = []    DOS = []    for currentFile, currentPath in allFPCombo:        if currentFile in filename:            currentPathList = currentPath.split('/')            desiredPathList = filepath            CPLIndex = len(currentPathList)-1            DPLIndex = len(desiredPathList)-1            degreeOfSimilarity = 0            while(CPLIndex != 0 and                  DPLIndex != 0 and                  currentPathList[CPLIndex] == desiredPathList[DPLIndex]):                CPLIndex -= 1                DPLIndex -= 1                degreeOfSimilarity += 1            FPDList.append([filename, currentPath, degreeOfSimilarity])        for F, P, D in FPDList:        DOS.append(D)    bestFPD = FPDList[DOS.index(max(DOS))]    bestFPCombo[bestFPD[0]] = bestFPD[1]### @patchFP( filename, filepath ):###     This function patch a file name with the path,###     each section of the path separated with '/'def patchFP( filename, filepath ):    newPath = filepath    oldFileName = filename.split('/')[-1]    return newPath + '/' + oldFileName### @relinkIt( filename, sourcePath ):###     This function is the one that actually relink the path to NUKE's read node.def relinkIt( filename, sourcepath, readnode ):    global bestFPCombo     P = bestFPCombo[filename]    F = filename    finalFileName = patchFP(F,P)    finalFileName = finalFileName.replace(sourcepath, '[value fxT_relinker.path]')    readnode['file'].setValue( finalFileName )### @relinkerMAIN():###     This is the main function called by fun()###     It gets the path from the user###     Calls all of the local methods to relink the filedef fxT_relinkerMAIN():        global sourcePath, bestFPCombo    sourcePath = nuke.toNode('fxT_relinker')["path"].value()    if not legalPath( sourcePath ):        nuke.message('The path selected does not exist. Please choose another path.')        return None    """making a function that the fun() can call (when pushing the button this get called)"""    """looping over all the readnodes in the script"""    for readnode in nuke.allNodes('Read'):                desiredFileName = readnode["file"].value()            ### desired file name -> string        desiredBaseName = getBaseName(desiredFileName)            ### desired base name -> string        desiredFilePath = getFilePath(desiredFileName)            ### desired file path -> list        desiredFileType = desiredFileName.split(".")[-1]            ### desired file type -> string        ### Implement search paradigm:        if desiredFileName not in bestFPCombo:            getALLFPCombo( desiredFileName, desiredBaseName, desiredFileType )            getBestFPCombo( desiredFileName, desiredFilePath )        relinkIt( desiredFileName, sourcePath, readnode )                nuke.toNode('fxT_relinker').hideControlPanel()